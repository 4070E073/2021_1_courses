封裝(Encapsulation)-意思是把有必要的內容對外來公開，沒有必要讓別人看到的內容則隱藏起來。

繼承(Inhertitance)-子類別使用上面父類別擁有的屬性和行為。

多型(polymorphism)-一件事物有多種不同的樣貌，在物件導向程式語言指的是同樣一個方法在不同類別中會有不同的內容。

#
```
java.util.Arrays

http://tw.gitbook.net/java/util/java_util_arrays.html
https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html

https://openhome.cc/Gossip/JavaGossip-V1/ArraysClass.htm
```
#
```
https://github.com/pedrovgs/Algorithms/blob/master/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java
```

# sort() and binarysearch()
```
https://en.wikipedia.org/wiki/Bubble_sort

Pseudocode implementation
In pseudocode the algorithm can be expressed as (0-based array):

procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n-1 inclusive do
            /* if this pair is out of order */
            if A[i-1] > A[i] then
                /* swap them and remember something changed */
                swap(A[i-1], A[i])
                swapped := true
            end if
        end for
    until not swapped
end procedure
```
```
Optimizing bubble sort
The bubble sort algorithm can be optimized by observing that the n-th pass finds the n-th largest element and puts it into its final place. So, the inner loop can avoid looking at the last n − 1 items when running for the n-th time:

procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n - 1 inclusive do
            if A[i - 1] > A[i] then
                swap(A[i - 1], A[i])
                swapped = true
            end if
        end for
        n := n - 1
    until not swapped
end procedure
```
#
```
The Art of Computer Programming, Volume 3 : Sorting and Searching, 2/e (Hardcover)
Donald E. Knuth
Addison Wesley
1998-04-24
https://www.tenlong.com.tw/products/9780201896855
```

#
```
public class MyArray1 {
	public static void main(String[] args) {
		int[] n = new int[] { 56, 45, 68, 32 };
		int sum = 0;
		for (int i=0; i<4 ; i++) {	      
		   // 使用迴圈逐一顯示n[0]~n[3]的值
			System.out.println(" n[" + i + "] = " + n[i]);
                        System.out.println(" n[" + i + "] address= " + &n[i]);
			sum += n[i];
		}
		System.out.println(" n 陣列元素總和為 " + sum);
	}
}
```
```
//package ex04;
import java.util.Scanner;
public class BinarySearch {
	public static void main(String[] args) {
		
		int[] aNum = new int[9];
		
		for (int i = 0; i < aNum.length; i++)
			aNum[i]=(int)(Math.random()*100)+1;	

		
		System.out.print(" 排序前：");		
		for (int a : aNum)	//使用加強型for迴圈讀取陣列元素值
			System.out.print("  " + a);
		System.out.println();
		
		
		int n = aNum.length;
		int t;

		for (int i = n - 2; i >= 0; i--) { // 進行氣泡排序法
			for (int j = 0; j <= i; j++) {
				if (aNum[j] > aNum[j + 1]) {
					 t = aNum[j];
					aNum[j] = aNum[j + 1];
					aNum[j + 1] = t;
				}
			}
		}
		
		
		System.out.print(" 排序後：");
		for (int a : aNum)
			System.out.print("  " + a);
		System.out.println();
		
		
		
		Scanner scn = new Scanner(System.in);
		System.out.print(" 請輸入要搜尋的數字： ");
		
		
		int sNum = scn.nextInt();
		int num = -1, low = 0, high = aNum.length - 1, midNum = 0;
		
		do {
			midNum = (low + high) / 2;
			
			if (aNum[midNum] == sNum) {  //若中間註標的陣列值和搜尋資料相同
				num = midNum;
				break;				//離開迴圈
			}
			
			if (aNum[midNum] > sNum)     //若中間註標的陣列值>搜尋資料
				high = midNum - 1;	//重設上界值
			else
				low = midNum + 1; 	//重設下界值
			
		} while (low <= high);		//若下界值 <= 上界值就繼續執行
		
		if (num == -1)
			System.out.println(" 沒有 " + sNum + " 這個數字! ");
		else
			System.out.println("排序後找到"+sNum+"是第"+(num +1)+ "個數字!");
		scn.close();
	}
}
```
