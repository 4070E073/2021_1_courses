#
```

https://github.com/foomur/programming-ground-up
```
```
Chapter 3 - Your first assembly program
exit.s - a first assembly program showing the functionality of the exit() syscall
maximum.s - finding the largest number in a data index
minimum.s - finding the smallest number in a data index


Chapter 4 - Functions
power.s - illustrating how functions work by solving 2^3 + 5^2
factorial.s - solving a factorial by creating a function
square.s - solving a square x^2 = ? by creating a function

Chapter 5 - Buffers & File Descriptors
toupper.s - using buffers and file descriptors to change all lowercase letters of a file to all uppercase letters


Chapter 6 - Reading and Writing Simple Records:
linux.s - common Linux definitions use .equ including syscalls, file descriptors, status codes, interrupts
record-def.s - record offsets
add-year.s - add a year to each record
count-chars.s - function to count the number of characters in a record
read-record.s - function to read a record
read-records.s - final program to read all the records
write-newline.s - function to write a newline to STDOUT
write-record.s - function to write in a record
write-records.s - final program to write all the records
```
# Chapter 3 - Your first assembly program
### exit.s - a first assembly program showing the functionality of the exit() syscall

```
#PURPOSE:  	Simple program that exits and returns a status code back to the Linux kernel

#INPUT:  	none

#OUTPUT: 	returns a status code.  This can be viewed by typing echo $? after 
#		running the program

#VARIABLES:
#		%eax holds the system call number
#		%ebx holds the return status
#

.section .data

.section .text
	.globl _start
_start:
	movl $1, %eax			# this is the linux kernel command
		 	            	# number (system call) for exiting a program
					
	movl $0, %ebx	 	   # this is the status number we will return to the operating
					           # system.  Change this around and it will return different
			       	        # things to echo $?

int $0x80				# this wakes up the kernel to run the exit command				
					
					
#TO RUN (from the command line):
#			            
#			as exit.s -o exit.o     	# Assemble the program
# 			ld exit.o -o exit		# Link the file
#			./exit				# Run the program
#			echo $?				# Should be 0, the exit status code	
```

### maximum.s - finding the largest number in a data index

```
#PURPOSE: 		This program finds the maximum number of a set of data items

#INPUT:  		

#OUTPUT: 				

#VARIABLES:		The registers have the following uses:
#					%edi - Holds the index of the data item being examined	
#					%ebx - Largest data item found
#					%eax - Current data item
#
#			The following memory locations are used:
#					data_items - contains the item data.  A 0 is used to terminate the data


.section .data

data_items:				# These are the data items
.long 3,67,34,222,45,75,54,34,44,33,22,11,66,0

.section .text

.globl _start
_start:
	movl $0, %edi					# Move 0 into the index register
	movl data_items(,%edi,4), %eax			# Load the first byte of data
	movl %eax, %ebx					# Since this is the first item, %eax is the biggest
	
	start_loop:					# Starts a loop
		cmpl $0, %eax				# Checks if we are at the end
		je loop_exit
		incl %edi				# Load next value
		movl data_items(,%edi,4), %eax
		cmpl %ebx, %eax				# Compare values
		jle start_loop				# Go back to start of loop if new value isn't bigger
		movl %eax, %ebx				# Move the value as the largest
		jmp start_loop				# jump to loop beginning
	
	loop_exit:
		
		movl $1, %eax				# 1 is the exit() syscall
		int $0x80 				# Send to Linux kernel
					
					
#TO RUN (from the command line):
#			
#	as maximum.s -o maximum.o     	# Assemble the program
# 	ld maximum.o -o maximum		# Link the file
#	./maximum			# Run the program
#	echo $?				# Should return 222

```


### minimum.s - finding the smallest number in a data index
```
#PURPOSE: 		This program finds the minimum number of a set of data items

#INPUT:  		

#OUTPUT: 				

#VARIABLES:		The registers have the following uses:
#					%edi - Holds the index of the data item being examined	
#					%ebx - Largest data item found
#					%eax - Current data item
#
#			The following memory locations are used:
#					data_items - contains the item data.  A 0 is used to terminate the data


.section .data

data_items:				# These are the data items
.long 3,67,34,222,45,75,54,34,44,33,22,11,66,255

.section .text

.globl _start
_start:
	movl $0, %edi					# Move 0 into the index register
	movl data_items(,%edi,4), %eax			# Load the first byte of data
	movl %eax, %ebx					# Since this is the first item, %eax is the biggest
	
	start_loop:					# Starts a loop
		cmpl $255, %eax				# Checks if we are at the end
		je loop_exit
		incl %edi				# Load next value
		movl data_items(,%edi,4), %eax
		cmpl %ebx, %eax				# Compare values
		jge start_loop				# Go back to start of loop if new value isn't smaller
		movl %eax, %ebx				# Move the value as the smallest
		jmp start_loop				# jump to loop beginning
	
	loop_exit:
		
		movl $1, %eax				# 1 is the exit() syscall
		int $0x80 				# Send to Linux kernel
					
					
#TO RUN (from the command line):
#			
#	as minimum.s -o minimum.o     	# Assemble the program
# 	ld minimum.o -o minimum		# Link the file
#	./minimum			# Run the program
#	echo $?				# Should return 3
```
## Chapter 4 - Functions

###
```
  
#PURPOSE: 		Program to illustrate how functions work
# 			This program will compute the value of 2^3 + 5^2
 				  
#			Everything in the main program is stored in registers,
#			so the data section doesnâ€™t have anything.

.code32           
.section .data
.section .text
.globl _start
_start:
	pushl $3 			 # push second argument
	pushl $2 			 # push first argument
	call power 		         # call the function
	addl $8, %esp 	                 # move the stack pointer back
	pushl %eax 			 # save the first answer before
			                 # calling the next function
	pushl $2 		  	 # push second argument
	pushl $5 			 # push first argument
	call power 			 # call the function
	addl $8, %esp 	                 # move the stack pointer back
	popl %ebx 			 # The second answer is already
				         # in %eax. We saved the
					 # first answer onto the stack,
					 # so now we can just pop it
					 # out into %ebx
	addl %eax, %ebx	                 # add them together
					 # the result is in %ebx
	movl $1, %eax 	                 # exit (%ebx is returned)
int $0x80
	
#PURPOSE: 		This function is used to compute the value of a number raised to a power
 				   				
#INPUT: 	  	First argument - the base number
# 			Second argument - the power to raise it to
# 				   

#OUTPUT: 		Will give the result as a return value

#NOTES: 		The power must be 1 or greater

#VARIABLES:
# 			%ebx - holds the base number
# 			%ecx - holds the power
# 			-4(%ebp) - holds the current result
# 			%eax is used for temporary storage


.type power, @function
power:
	pushl %ebp 			  # save old base pointer
	movl %esp, %ebp 		  # make stack pointer the base pointer
	subl $4, %esp 			  # get room for our local storage
	movl 8(%ebp), %ebx 		  # put first argument in %eax
	movl 12(%ebp), %ecx 		  # put second argument in %ecx
	movl %ebx, -4(%ebp) 		  # store current result
	
power_loop_start:
	
	cmpl $1, %ecx 			  # if the power is 1, we are done
	je end_power
	movl -4(%ebp), %eax 		  # move the current result into %eax
	imull %ebx, %eax 		  # multiply the current result by
					  # the base number
	movl %eax, -4(%ebp) 	          # store the current result
	decl %ecx 		          # decrease the power
	jmp power_loop_start 	          # run for the next power
	
end_power:
	movl -4(%ebp), %eax 	          # return value goes in %eax
	movl %ebp, %esp 		  # restore the stack pointer
	popl %ebp 			  # restore the base pointer
ret



#    To run, from the command line (I'm using an x86-64 build so you may need to assemble differently)
#  		    	as --32 power.s -o power.o
#			ld -melf_i386 power.o -o power
#			./power
#			echo $?

```


##
```


```


##
```


```


##
```


```


##
```


```
