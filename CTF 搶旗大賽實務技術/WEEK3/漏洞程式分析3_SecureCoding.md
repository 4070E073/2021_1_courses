# 漏洞程式分析3_SecureCoding
```
萬無一失的程式碼：終結C&C++軟體漏洞
書號：PG21336	作者：Robert C. Seacord	ISBN： 978-986-201-975-7
2014/12/25

http://www.drmaster.com.tw/Bookinfo.asp?BookID=PG21336
```
```
https://github.com/mparisi20/secure-coding-in-c-and-cpp
```

```
Chapter 1　規範執行
Chapter 2　字串
Chapter 3　指標困擾
Chapter 4　動態記憶體管理
Chapter 5　整數安全
Chapter 6　格式化輸出
Chapter 7　協同處理
Chapter 8　檔案輸入輸出
Chapter 9　實作建議
```

# 章節目錄
```
第1章  夾縫求生
1.1  衡量危險
1.1.1  損失的現狀
1.1.2  威脅的來源
1.1.3  軟件安全
1.2  安全概念
1.2.1  安全策略
1.2.2  安全缺陷
1.2.3  漏洞
1.2.4  漏洞利用
1.2.5  緩解措施
1.3  C和C++
1.3.1  C和C++簡史
1.3.2  C存在的問題
1.3.3  遺留代碼
1.3.4  其他語言
1.4  開發平臺
1.4.1  操作系統
1.4.2  編譯器


第2章  字符串
2.1  字符串
2.1.1  字符串數據類型
2.1.2  UTF-8
2.1.3  寬字符串
2.1.4  字符串字面值
2.1.5  C++中的字符串
2.1.6  字符類型
2.1.7  計算字符串大小
2.2  常見的字符串操作錯誤
2.2.1  無界字符串複製
2.2.2  差一錯誤
2.2.3  空字符結尾錯誤
2.2.4  字符串截斷
2.2.5  與函數無關的字符串錯誤
2.3  字符串漏洞及其利用
2.3.1  被污染的數據
2.3.2  IsPasswordOK的安全缺陷
2.3.3  緩衝區溢出
2.3.4  進程內存組織
2.3.5  棧管理
2.3.6  棧溢出
2.3.7  代碼註入
2.3.8  弧註入
2.3.9  返回導向編程
2.4  字符串漏洞緩解策略
2.4.1  字符串處理
2.4.2  C11附錄K邊界檢查接口
2.4.3  動態分配函數
2.4.4  C++ std：：basic_string
2.4.5  使字符串對象的引用失效
2.4.6  使用basic_string的其他常見錯誤
2.5  字符串處理函數
2.5.1  gets
2.5.2  C99
2.5.3  C11附錄K邊界檢查接口：gets-s
2.5.4  動態分配函數
2.5.5  strcpy和strcat
2.5.6  C99
2.5.7  strncpy和strncat
2.5.8  memcpy和memmove
2.5.9  strlen
2.6  運行時保護策略
2.6.1  檢測和恢復
2.6.2  輸入驗證
2.6.3  對象大小檢查
2.6.4  Visual Studio中編譯器生成的運行時檢查
2.6.5  棧探測儀
2.6.6  棧溢出保護器
2.6.7  操作系統策略
2.6.8  檢測和恢復
2.6.9  不可執行棧
2.6.10  W^X
2.6.11  PaX
2.6.12  未來發展方向
2.7  著名的漏洞
2.7.1  遠程登錄
2.7.2  Kerberos


第3章  指針詭計
3.1  數據位置
3.2  函數指針
3.3  對象指針
3.4  修改指令指針
3.5  全局偏移表
3.6  dtors區
3.7  虛指針
3.8  atexit和on-exit函數
3.9  longjmp函數
3.10  異常處理
3.10.1  結構化異常處理
3.10.2  系統默認異常處理
3.11  緩解策略
3.11.1  棧探測儀
3.11.2  W-X
3.11.3  對函數指針編碼和解碼


第4章  動態內存管理
4.1  C內存管理
4.1.1  C標準內存管理函數
4.1.2  對齊
4.1.3  alloca和變長數組
4.2  常見的C內存管理錯誤
4.2.1  初始化錯誤
4.2.2  未檢查返回值
4.2.3  Null或無效指針解引用
4.2.4  引用已釋放內存
4.2.5  多次釋放內存
4.2.6  內存泄漏
4.2.7  零長度分配
4.2.8  DR # 400
4.3  C++的動態內存管理
4.3.1  分配函數
4.3.2  釋放函數
4.3.3  垃圾回收
4.4  常見的C++內存管理錯誤
4.4.1  未能正確檢查分配失敗
4.4.2  不正確配對的內存管理函數
4.4.3  多次釋放內存
4.4.4  釋放函數拋出一個異常
4.5  內存管理器
4.6  Doug Lea的內存分配器
4.7  雙重釋放漏洞
4.7.1  寫入已釋放的內存
4.7.2  RtlHeap
4.7.3  緩衝區溢出（終極版）
4.8  緩解策略
4.8.1  空指針
4.8.2  一致的內存管理約定
4.8.3  phkmalloc
4.8.4  隨機化
4.8.5  OpenBSD
4.8.6  jemalloc內存管理器
4.8.7  靜態分析
4.8.8  運行時分析工具
4.9  值得註意的漏洞
4.9.1  CVS緩衝區溢出漏洞
4.9.2  Microsoft數據訪問組件
4.9.3  CVS服務器雙重釋放漏洞
4.9.4  MIT Kerberos 5中的漏洞


第5章  整數安全
5.1  整數安全導論
5.2  整數數據類型
5.2.1  無符號整數類型
5.2.2  迴繞
5.2.3  有符號整數類型
5.2.4  有符號整數的取值範圍
5.2.5  整數溢出
5.2.6  字符類型
5.2.7  數據模型
5.2.8  其他整數類型
5.3  整數轉換
5.3.1  轉換整數
5.3.2  整數轉換級別
5.3.3  整數類型提升
5.3.4  普通算術轉換
5.3.5  由無符號整數類型轉換
5.3.6  由有符號整數類型轉換
5.3.7  轉換的影響
5.4  整數操作
5.4.1  賦值
5.4.2  加法
5.4.3  減法
5.4.4  乘法
5.4.5  除法和求餘
5.4.6  移位
5.5  整數漏洞
5.5.1  漏洞
5.5.2  迴繞
5.5.3  轉換和截斷錯誤
5.5.4  非異常的整數邏輯錯誤
5.6  緩解策略
5.6.1  整數類型的選擇
5.6.2  抽象數據類型
5.6.3  任意精度算術
5.6.4  範圍檢查
5.6.5  前提條件和後驗條件測試
5.6.6  安全整數庫
5.6.7  溢出檢測
5.6.8  編譯器生成的運行時檢查
5.6.9  可驗證範圍操作
5.6.10  仿佛無限範圍整數模型
5.6.11  測試與分析


第6章  格式化輸出
6.1  變參函數
6.2  格式化輸出函數
6.2.1  格式字符串
6.2.2  GCC
6.2.3  Visual C++
6.3  對格式化輸出函數的漏洞利用
6.3.1  緩衝區溢出
6.3.2  輸出流
6.3.3  使程序崩潰
6.3.4  查看棧內容
6.3.5  查看內存內容
6.3.6  覆寫內存
6.3.7  國際化
6.3.8  寬字符格式字符串漏洞
6.4  棧隨機化
6.4.1  阻礙棧隨機化
6.4.2  以雙字的格式寫地址
6.4.3  直接參數訪問
6.5  緩解策略
6.5.1  排除用戶輸入的格式字符串
6.5.2  靜態內容的動態使用
6.5.3  限制字節寫入
6.5.4  C11附錄K邊界檢查接口
6.5.5  iostream與stdio
6.5.6  測試
6.5.7  編譯器檢查
6.5.8  靜態污點分析
6.5.9  調整變參函數的實現
6.5.10  Exec Shield
6.5.11  FormatGuard
6.5.12  靜態二進制分析
6.6  著名的漏洞
6.6.1  華盛頓大學FTP Daemon
6.6.2  CDE ToolTalk
6.6.3  Ettercap NG-0.7.2版


第7章  併發
7.1  多線程
7.2  並行
7.2.1  數據並行
7.2.2  任務並行
7.3  性能目標
7.4  常見錯誤
7.4.1  競爭條件
7.4.2  損壞的值
7.4.3  易變的對象
7.5  緩解策略
7.5.1  內存模型
7.5.2  同步原語
7.5.3  線程角色分析（研究）
7.5.4  不可變的數據結構
7.5.5  併發代碼屬性
7.6  緩解陷阱
7.6.1  死鎖
7.6.2  過早釋放鎖
7.6.3  爭用
7.6.4  ABA問題
7.7  值得註意的漏洞
7.7.1  在多核動態隨機訪問存儲器系統中的DoS攻擊
7.7.2  系統調用包裝器中的併發漏洞

第8章  文件I/O
8.1  文件I/O基礎
8.1.1  文件系統
8.1.2  特殊文件
8.2  文件I/O接口
8.2.1  數據流
8.2.2  打開和關閉文件
8.2.3  POSIX
8.2.4  C++中的文件I/O
8.3  訪問控制
8.3.1  UNIX文件權限
8.3.2  進程特權
8.3.3  更改特權
8.3.4  管理特權
8.3.5  管理權限
8.4  文件鑒定
8.4.1  目錄遍歷
8.4.2  等價錯誤
8.4.3  符號鏈接
8.4.4  規範化
8.4.5  硬鏈接
8.4.6  設備文件
8.4.7  文件屬性
8.5  競爭條件
8.5.1  檢查時間和使用時間
8.5.2  創建而不替換
8.5.3  獨佔訪問
8.5.4  共享目錄
8.6  緩解策略
8.6.1  關閉競爭窗口
8.6.2  消除競爭對象
8.6.3  控制對競爭對象的訪問
8.6.4  競爭檢測工具


第9章  推薦的實踐
9.1  安全開發生命周期
9.1.1  TSP-Secure
9.1.2   計劃和跟蹤
9.1.3  質量管理
9.2  安全培訓
9.3  要求
9.3.1  安全編碼標準
9.3.2  安全質量需求工程
9.3.3  用例/誤用例
9.4  設計
9.4.1  安全的軟件開發原則
9.4.2  威脅建模
9.4.3  分析攻擊面
9.4.4  現有代碼中的漏洞
9.4.5  安全包裝器
9.4.6  輸入驗證
9.4.7  信任邊界
9.4.8  黑名單
9.4.9  白名單
9.4.10  測試
9.5  實現
9.5.1  編譯器檢查
9.5.2  仿佛無限範圍整數模型
9.5.3  有安全保證的C/C++
9.5.4  靜態分析
9.5.5  源代碼分析實驗室
9.5.6  深層防禦
9.6  驗證
9.6.1  靜態分析
9.6.2  滲透測試
9.6.3  模糊測試
9.6.4  代碼審計
9.6.5  開發人員準則與檢查清單
9.6.6  獨立安全審查
9.6.7  攻擊面回顧
9.7  小結
9.8  閱讀材料
```
