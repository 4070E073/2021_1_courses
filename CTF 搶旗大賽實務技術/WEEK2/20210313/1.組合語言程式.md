# A_0_組合語言程式語法與解讀_起手式.md
```
產生組合語言
(1)使用gcc/g++產生組合語言   ==> gcc/g++
(2)使用逆向程式工具把執行檔逆回組合語言 ==> objdump  
(3)直接使用nasm/masm/fasm/gas/....撰寫組合語言程式 ==> GAS nasm
```

```
// helloCTFer.c
#include <stdio.h>

int main()
{
   printf("Hello CTFer\n ”);
   return 0;
}
```
### (1)使用gcc/g++產生組合語言
```
[32bit與64bit組合語言不一樣!!]

產生預設的AT&T 語法的組合語言
    gcc -S func1.c -o func1.s

產生intel 語法的組合語言
    gcc -S -masm=intel func1.c -o func1_intel.s

gcc -S -masm=intel func1.c -o func1_intel.s -fno-asynchronous-unwind-tables
```
```
// helloCTFer.c
#include <stdio.h>

int main()
{
   printf("Hello CTFer\n ”);
   return 0;
}
```
### (2)使用逆向程式工具把執行檔逆回組合語言 ==> objdump  
```
gcc helloCTFer.c -o helloCTFer -g
    原始C程式        執行檔      重要編譯參數
```

```
objdump -S helloCTFer  ==> AT&T

objdump -S -M intel helloCTFer

objdump -S -j .text -M intel helloCTFer

objdump -S -j .text -M intel helloCTFer --no-show-raw-insn  
```


### (3)直接使用nasm/masm/fasm/gas/....撰寫組合語言程式 ==> GAS nasm
```

```

# 組合語言程式的核心語法
## 計算機組織
```
計算體系結構
處理器(CPU)
緩存|快取(cache)與暫存器(register)
64 位處理器
指令的執行
指令流水線(pipeline)
輸入與輸出(input | output)
```
```
資料表達data representation
```

## 彙編語言及其語法
```
彙編程式的五大支柱
宇面量
標簽與注釋
```

## 基本指令
```
資料的移動與算術運算
資料移動
加法與減法
乘法與除法
移位
處理負值
```

```
資料的定址與傳輸
資料對齊
資料尋址
```

```
Array(數組|陣列)
改變資料的大小及類型
```

## 中級指令
```
Bitwise(按位執行的)布林運算
```

### 分支
```
無條件跳轉
有條件跳轉
複合條件
```
### 重複執行(loop)
```
使用CX/ECX爾EX 計數器實現循環
使用用開發者自訂的計數器實現循環
```

## 函數(function)|方法(method)|程序(procedure)
```
memory記憶體與 stack heap
stack的運算
```

```
呼叫約定(Calling convention)
x86 (32 位元)呼叫約定 ==> cdecl   stdcall
x86_64 呼叫約定==>x86_64 (64 位）
```

```
沒帶參數的函數呼叫
帶參數的函數呼叫
```

## 字串處裡相關指令
```
MOVS 
CMPS 
SCAS 
STOS 
LOOS
```
## 結構體
## 浮點數運算(略)

## 內聯彙編與宏
```
內聯彙編
與編譯器有關的細節
內聯式的彙編語句
為各種彙編方言提供支持
注意事項
宏
對比巨集與函數
定義並調用宏
```

## 中斷與系統呼叫
```
軟體中斷
硬體中斷
```
```
通過INT 進行系統呼叫(舊方法)
通過SYSENTER、SYSCALL及程式庫/AP! 進行系統呼叫(新方法)
```

# 指令集架構(Instruction Set Architecture, ISA)
```
指令集架構(Instruction Set Architecture, ISA) 是電腦體系結構中與程式設計有關的方面。
它指出了處理器所具備的指令、寄存器、記憶體架構、資料類型以及其他一些屬性，以供程式員使用。
你可以把ISA 理解成電腦所說的語言，它能夠促進軟體與硬體之間的通信

指令集架構分為複雜與精簡兩種。
複雜指令集(Complex Instruction Set Computing,CISC) 架構中的指令，
其長度（也就是表示該指令所需的位元組數）不固定。
之所以說它複雜，是因為一條指令有可能要完成多項任務，
比方說，既要訪間某個記憶體位址，又要執行算術運算。

與之相對的ISA 設計稱為精簡指令集(Reduced Instruction Set Computing, RISC)
其中的所有指令都一樣長，而且只執行一項任務（例如只訪間某個記憶體位址，不做其他的事情）。

x86 與x86_64 都是CISC 架構，
其他一些ISA 設計方案則多為RISC 架構。

32 位x86 指令集架構的常用名稱==> x86    IA-32   i386
64 位x86 指令集架構的常用名稱==> x64  x86_64
                              Intel: IA-32e （原名）、Intel 64 （當前名稱）AMD: AMD64
                              
64 位版的x86 與64 位的Intel Architecture （簡稱IA-64) 是兩種完全不同的架構，
後者是Itanium （安騰）系列處理器所用的指令集，它與IA-32 及x64 均不相容。                          
```
```
https://en.wikipedia.org/wiki/X86
https://en.wikipedia.org/wiki/X86-64
```
# 為什麼要學習組合語言
```
·學習組合語言可以更好地理解電腦的操作。程式師可以通過彙編這種手段來瞭解
計算機硬體、CPU 元件以及記憶體佈局等細節，並知道電腦體系結構中的這些要素
是怎樣交互的。
．編寫彙編代碼時，程式師可以頻繁使用調試器來排查代碼中的錯誤。它提供了彙編、
反彙編等功能，還可以查看寄存器與記憶體資訊，以便在底層單步地執行程式。理解
匯編語言與電腦體系結構，能夠説明開發者更好地找到並修復代碼中的bug 。
．瞭解組合語言及電腦操作，能夠説明開發者對高層及底層的實現問題做出更加明
智的決策，從而可以充分利用硬體的特徵來優化程式的效率。
·懂得組合語言可以令你在完成位操作(bit manipulation) 及函式呼叫(function call,
也稱為procedure call, 過程洞用）等任務時，省去很多抽象環節。
·必須非常熟悉彙編才能夠進入某些軟體發展領域，例如嵌入式設備的程式設計、設備驅
動程式的程式設計，以及作業系統程式設計等。
總之，學習組合語言，可以令你更加全面地理解電腦的操作原理及代碼的運行機制，
從而能夠更好地利用這些知識。此
```

# 64 位及32 位元register的特殊用法
```
rax|eax 通常是預設的累加寄存器

乘法等操作會將其中一部分結果自動存放到rax|eax 

呼叫函數的時候也需要把返回值保存在rax|eax 中

因此，執行這些操作時不要用rax|eax 保存一般的資料。
```

```
rcx|ecx 用來在執行迴圈loop的過程中記錄迴圈計數器的值

因此，在迴圈內部不要用rcx/ecx 保存一般的資料。
```
```
rbp|ebp 用作棧幀中的幀指標，這會在第6 章講解。該寄存器用來指向棧中的資料，
筆者建議只把它當作專門的寄存器來用。

rsp|esp 是棧指標寄存器，這也是個與棧管理有關的寄存器，它一般指向活動棧幀的
頂部。與前一個寄存器一樣，這個寄存器也只應該當成專門的寄存器來用。
```
```
rsi|esi 與動／edi 是索引寄存器(index register, 也稱為變址寄存器），它和STOSB 、
MOVSB 與SCASB 這樣的字串操作結合起來使用，以便保存、載入或掃描大攝的
數據。這些操作實際上會把CPU 置於一種自動迴圈模式中，這要比開發者手工編寫
循環更有效率。
```
```
rip/eip 是擴展版的指令指標寄存器。
這個寄存器用來指向記憶體中的位址，以表示接下來應該獲取、解碼並執行的指令
它是在程式運行過程中自動調整的，不應該通過編程的手段修改。
```
```
• rjlags!ejlags 是狀態與控制寄存器，這會在接下來的內容裡詳細講解。LAHF 與
SAHF 等特殊指令可以把CPU 的一些狀態標誌載入ah 寄存器，或是將ah 寄存器裡
的值保存到狀態寄存器中。除此以外，不應該用其他手段直接修改rjlags!ejlags 。該
寄存器裡的二進位位元是在執行完算數運算之後根據一套布林規則自動設置的。儘管
rjlags 是64 位，但其中能夠用到的只有低32 位，因此， x86 與x86_64 處理器用的
是同一套狀態標誌。
```

# CPU 標誌(CPU flag)
```
CPU 標誌(CPU flag) 是一些二進位位元的統稱
這些二進位位元分別用來以某種方式控制CPU 操作或反映CPU 操作的狀態。

表2-7 列出了大多數開發環境中值得關注的8 個標誌位元，其中某些標誌可以由開發者通過LAHF 及SAHF 指令來操作。
表2-8 列出了可以由這些指令所編輯的標誌位元。

對於標誌位元來說， 
set （設置）的意思是將其設為1 （也稱為置I),
clear （清除）的意思是將其設為0 （也稱為置0) 。
```


# 指令執行週期與 pileline
```
指令執行週期一般表示成Fetch獲取、Decode解碼及Execute執行三階段

獲取階段==> CPU 會把將要執行的[rip!eip 所指向的]指令取出來。

解碼階段==> CPU要判斷這是一條什麼樣的指令，它需要操作哪些資料。
為此，它會查看指令碼中的二進位位元以瞭解該指令的類型(ADD 、SUB, 還是MOV) 以及是否包含運算元。
如果包含運算元，那還需要把運算元也獲取過來。將所有的資料都獲取到並加以解碼

執行階段==> 解碼之後CPU 就可以執行這條指令了。
如果執行之後產生了結果（例如ADD 及SUB 指令），那麼CPU 會把該結果保存到適當的地方（例如寄存器或記憶體）
```

## 程式載入
```
程式是由一個叫作程式載入器的工具來載入的。

載入進來之後， CPU (的eip/rip 寄存器）指向程式的入口點，這個入口點可能叫作main 或start 等。
下面描述啟動程式的一般步驟。當使用者開啟程式（例如用滑鼠按兩下程式的圖示）時：
l.作業系統把檔的大小以及該檔在磁片中的物理位置等資訊獲取出來。
2.作業系統在記憶體中尋找合適的地點分配空間，並把必要的資訊放在描述符表(descriptor table) 中（第10 章會講解描述符）。
3.作業系統開始執行程式的第一條指令（也就是位於入口點的那條指令）。
  這使程式(program)變為進程(process)，並獲得由系統所賦予的ID(PID) 。
4.process自行運作，而作業系統則會對進程所發出的資源請求予以回應。
5.process結束並釋放出它所佔據的記憶體
```



```



```


```


```


```



```



```


```


```


```



```



```


```


```


```



```
