# A_0_組合語言程式語法與解讀_起手式.md
```
產生組合語言
(1)使用gcc/g++產生組合語言   ==> gcc/g++
(2)使用逆向程式工具把執行檔逆回組合語言 ==> objdump  
(3)直接使用nasm/masm/fasm/gas/....撰寫組合語言程式 ==> GAS nasm
```
# (1)使用gcc/g++產生組合語言[32bit與64bit組合語言不一樣!!]
```
產生預設的AT&T 語法的組合語言
    gcc -S func1.c -o func1.s

產生intel 語法的組合語言
    gcc -S -masm=intel func1.c -o func1_intel.s

gcc -S -masm=intel func1.c -o func1_intel.s -fno-asynchronous-unwind-tables
```
# (2)使用逆向程式工具把執行檔逆回組合語言 ==> objdump  
```

```
# (3)直接使用nasm/masm/fasm/gas/....撰寫組合語言程式 ==> GAS nasm
```

```

# 組合語言程式的核心語法
## 計算機組織
```
計算體系結構
處理器(CPU)
緩存|快取(cache)與暫存器(register)
64 位處理器
指令的執行
指令流水線(pipeline)
輸入與輸出(input | output)
```
```
資料表達data representation
```

## 彙編語言及其語法
```
彙編程式的五大支柱
宇面量
標簽與注釋
```

## 基本指令
```
資料的移動與算術運算
資料移動
加法與減法
乘法與除法
移位
處理負值
```

```
資料的定址與傳輸
資料對齊
資料尋址
```

```
Array(數組|陣列)
改變資料的大小及類型
```

## 中級指令
```
Bitwise(按位執行的)布林運算
```

### 分支
```
無條件跳轉
有條件跳轉
複合條件
```
### 重複執行(loop)
```
使用CX/ECX爾EX 計數器實現循環
使用用開發者自訂的計數器實現循環
```

## 函數(function)|方法(method)|程序(procedure)
```
memory記憶體與 stack heap
stack的運算
```

```
呼叫約定(Calling convention)
x86 (32 位元)呼叫約定 ==> cdecl   stdcall
x86_64 呼叫約定==>x86_64 (64 位）
```

```
沒帶參數的函數呼叫
帶參數的函數呼叫
```

## 字串處裡相關指令
```
MOVS 
CMPS 
SCAS 
STOS 
LOOS
```
## 結構體
## 浮點數運算(略)

## 內聯彙編與宏
```



內聯彙編
與編譯器有關的細節
內聯式的彙編語句
為各種彙編方言提供支持
注意事項
宏
對比巨集與函數
定義並調用宏
```

## 中斷與系統呼叫
```
軟體中斷
硬體中斷
```
```
通過INT 進行系統呼叫(舊方法)
通過SYSENTER、SYSCALL及程式庫/AP! 進行系統呼叫(新方法)
```


```


```



```



```


```


```


```



```



```


```


```


```



```



```


```


```


```



```



```


```


```


```



```



```


```


```


```



```
