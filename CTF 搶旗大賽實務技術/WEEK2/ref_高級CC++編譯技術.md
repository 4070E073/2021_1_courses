#
```
高級C/C++編譯技術
（美）斯特瓦諾維奇
機械工業出版社  2015/04/01

Advanced C and C++ Compiling (Paperback)
英文/Milan Stevanovic/Apress出版日期：2014-04-28

https://github.com/apress/adv-c-cpp-compiling

https://book.douban.com/subject/26414485/
```

```
第1章 多工作業系統基礎 1
1.1 一些有用的抽象概念 1
1.2 記憶體層次結構與緩存策略 2
1.3 虛擬記憶體 3
1.4 虛擬位址 5
1.5 進程的記憶體劃分方案 5
1.6 二進位檔案、編譯器、連結器與裝載器的作用 6
1.7 小結 7

第2章 程式生命週期階段基礎 8
2.1 基本假設 8
2.2 編寫代碼 9
2.3 編譯階段 11
2.3.1 基本概念 11
2.3.2 相關概念 11
2.3.3 編譯的各個階段 12
2.3.4 目的檔案屬性 23
2.3.5 編譯過程的局限性 24
2.4 連結 26
2.4.1 連結階段 26
2.4.2 連結器視角 31
2.5 可執行檔屬性 33
2.5.1 各種節的類型 34
2.5.2 各種符號類型 36

第3章 載入程式執行階段 37
3.1 shell的重要性 37
3.2 內核的作用 39
3.3 裝載器的作用 39
3.3.1 裝載器視角下的二進位檔案（節與段） 39
3.3.2 程式載入階段 40
3.4 程式執行入口點 43
3.4.1 裝載器查找入口點 43
3.4.2 _start()函數的作用 43
3.4.3 __libc_start_main()函數的作用 44
3.4.4 棧和調用慣例 44




第4章 重用概念的作用 46
4.1 靜態程式庫 46
4.2 動態庫 48
4.2.1 動態庫和共用庫 49
4.2.2 動態連結詳解 51
4.2.3 Windows平臺中動態連結的特點 54
4.2.4 動態庫的特點 56
4.2.5 應用程式二進位介面（ABI） 56
4.3 靜態程式庫和動態庫對比 57
4.3.1 導入選擇條件的差異 57
4.3.2 部署難題 59
4.4 一些有用的類比 61
4.5 結論：二進位複用概念所產生的影響 63

第5章 使用靜態程式庫 64
5.1 創建靜態程式庫 64
5.1.1 創建Linux靜態程式庫 64
5.1.2 創建Windows靜態程式庫 65
5.2 使用靜態程式庫 65
5.3 靜態程式庫設計技巧 66
5.3.1 丟失符號可見性和唯一性的可能性 66
5.3.2 靜態程式庫使用禁忌 67
5.3.3 靜態程式庫連結的具體規則 68
5.3.4 將靜態程式庫轉換成動態庫 68
5.3.5 靜態程式庫在64位Linux平臺上的問題 68

第6章 設計動態連結程式庫：基礎篇 70
6.1 創建動態連結程式庫 70
6.1.1 在Linux中創建動態庫 70
6.1.2 在Windows中創建動態連結程式庫 72
6.2 設計動態庫 75
6.2.1 設計二進位介面 75
6.2.2 設計應用程式的二進位介面 79
6.2.3 控制動態庫符號的可見性 82
6.2.4 完成連結需要滿足的條件 94
6.3 動態連結模式 94
6.3.1 載入時動態連結 95
6.3.2 運行時動態連結 95
6.3.3 比較兩種動態連結模式 98

第7章 定位庫文件 99
7.1 典型用例場景 99
7.1.1 開發用例場景 99
7.1.2 用戶運行時用例場景 100
7.2 構建過程中庫檔的定位規則 101
7.2.1 Linux平臺構建過程中的庫檔定位規則 101
7.2.2 Windows構建過程中的庫檔定位規則 105
7.3 運行時動態庫檔的定位規則 109
7.3.1 Linux運行時動態庫檔的定位規則 110
7.3.2 Windows運行時動態庫檔的定位規則 114
7.4 示例：Linux構建時與運行時的庫檔定位 115

第8章 動態庫的設計：進階篇 119
8.1 解析記憶體位址的必要性 119
8.2 引用解析中的常見問題 120
8.3 位址轉換引發的問題 122
8.3.1 情景1：客戶二進位程式需要知道動態庫符號位址 122
8.3.2 情景2：被裝載的庫不需要知道其自身符號位址 123
8.4 連結器-裝載器協作 124
8.4.1 總體策略 125
8.4.2 具體技術 126
8.4.3 連結器重定位提示概述 127
8.5 連結器-裝載器協作實現技術 128
8.5.1 裝載時重定位（LTR） 129
8.5.2 位置無關代碼（PIC） 129

第9章 動態連結時的重複符號處理 134
9.1 重複的符號定義 134
9.2 重複符號的預設處理 137
9.3 在動態庫連結過程中處理重複符號 140
9.3.1 處理重複符號問題的一般策略 142
9.3.2 連結器解析動態庫重複符號的模糊演算法準則 143
9.4 特定重複名稱案例分析 144
9.4.1 案例1：客戶二進位檔案符號與動態庫ABI函數衝突 144
9.4.2 案例2：不同動態庫的ABI符號衝突 147
9.4.3 案例3：動態庫ABI符號和另一個動態庫局部符號衝突 151
9.4.4 案例4：兩個未匯出的動態庫符號衝突 153
9.5 小提示：連結並不提供任何類型的命名空間繼承 161

第10章 動態庫的版本控制 162
10.1 主次版本號與向後相容性 162
10.1.1 主版本號變更 162
10.1.2 次版本號變更 163
10.1.3 修訂版本號 163
10.2 Linux動態庫版本控制方案 163
10.2.1 基於soname的版本控制方案 163
10.2.2 基於符號的版本控制方案 169
10.3 Windows動態庫版本控制 190
10.3.1 DLL版本資訊 191
10.3.2 指定DLL版本資訊 192
10.3.3 查詢並獲取DLL版本資訊 193

第11章 動態庫：其他主題 202
11.1 外掛程式 202
11.1.1 匯出規則 203
11.1.2 一些流行的外掛程式架構 204
11.2 提示和技巧 204
11.2.1 使用動態庫的實際意義 204
11.2.2 其他主題 205


第12章 Linux工具集 211
12.1 快速查看工具 211
12.1.1 file實用程式 211
12.1.2 size實用程式 212
12.2 詳細資訊分析工具 212
12.2.1 ldd 212
12.2.2 nm 214
12.2.3 objdump 215
12.2.4 readelf 223
12.3 部署階段工具 229
12.3.1 chrpath 229
12.3.2 patchelf 230
12.3.3 strip 231
12.3.4 ldconfig 231
12.4 運行時分析工具 232
12.4.1 strace 232
12.4.2 addr2line 233
12.4.3 gdb（GNU調試器） 233
12.5 靜態程式庫工具 234


第13章 平臺實踐 238
13.1 連結過程調試 238
13.2 確定二進位檔案類型 239
13.3 確定二進位檔案入口點 240
13.3.1 獲取可執行檔入口點 240
13.3.2 獲取動態庫入口點 240
13.4 列出符號資訊 241
13.5 查看節的信息 242
13.5.1 列出所有節的資訊 242
13.5.2 查看節的信息 242
13.6 查看段的信息 243
13.7 反彙編代碼 244
13.7.1 反彙編二進位檔案 244
13.7.2 反彙編正在運行的進程 244
13.8 判斷是否為調試構建 244
13.9 查看載入時依賴項 245
13.10 查看裝載器可以找到的庫檔 245
13.11 查看運行時動態連結的庫檔 245
13.11.1 strace實用程式 245
13.11.2 LD_DEBUG環境變數 246
13.11.3 /proc//maps文件 246
13.11.4 lsof實用程式 247
13.11.5 通過程式設計方式查看 248
13.12 創建和維護靜態程式庫 251


第14章 Windows工具集 252
14.1 庫管理器（lib.exe） 252
14.1.1 使用lib.exe處理靜態程式庫 253
14.1.2 使用lib.exe處理動態庫（導入庫生成工具） 257
14.2 dumpbin實用程式 258
14.2.1 確定二進位檔案類型 258
14.2.2 查看DLL的匯出符號 258
14.2.3 查看節的信息 259
14.2.4 反彙編代碼 262
14.2.5 確定是否使用了調試模式構建 263
14.2.6 查看載入時依賴項 265
14.3 Dependency Walker工具 265

```
