#
```
奔跑吧 Linux 內核 (捲1)：基礎架構, 2/e
笨叔    人民郵電   2021-01-01
ISBN: 7115549990
ISBN-13: 9787115549990

本書基於Linux 5.0內核的源代碼講述Linux內核中核心模塊的實現。
本書共9章，主要內容包括處理器架構、ARM64在Linux內核中的實現、內存管理之預備知識、
物理內存與虛擬內存、內存管理之高級主題、內存管理之實戰案例、進程管理之基本概念、
進程管理之調度和負載均衡、進程管理之調試與案例分析。
```

```
第　1章 處理器架構　1
1.1　處理器架構介紹　3
1.1.1　精簡指令集和復雜指令集　3
1.1.2　大/小端字節序　3
1.1.3　一條存儲讀寫指令的執行全過程　4
1.1.4　內存屏障產生的原因　8
1.1.5　高速緩存的工作方式　10
1.1.6　高速緩存的映射方式　11
1.1.7　組相聯的高速緩存　13
1.1.8　PIPT和VIVT的區別　14
1.1.9　頁表的創建和查詢過程　17
1.1.10　TLB　21
1.1.11　MESI協議　21
1.1.12　高速緩存偽共享　26
1.1.13　高速緩存在Linux內核中的應用　27
1.1.14　ARM的大/小核架構　28
1.1.15　高速緩存一致性和一致性內存模型　30
1.1.16　高速緩存的回寫策略和替換策略　30
1.1.17　NUMA　31
1.1.18　ARM處理器設計　32
1.1.19　最新進展　33
1.2　ARM64架構　34
1.2.1　ARMv8-A架構　34
1.2.2　採用ARMv8架構的常見處理器內核　35
1.2.3　ARMv8架構中的基本概念　35
1.2.4　ARMv8處理器執行狀態　36
1.2.5　ARMv8支持的數據寬度　36
1.2.6　不對齊訪問　37
1.3　ARMv8寄存器　37
1.3.1　通用寄存器　37
1.3.2　處理器狀態　38
1.3.3　特殊寄存器　39
1.3.4　系統寄存器　41
1.4　A64指令集　42
1.4.1　常用的算術和搬移指令　42
1.4.2　乘法和除法指令　43
1.4.3　移位操作指令　45
1.4.4　位操作指令　45
1.4.5　條件操作　47
1.4.6　內存加載指令　48
1.4.7　多字節內存加載和存儲指令　50
1.4.8　非特權訪問級別的加載和存儲指令　50
1.4.9　內存屏障指令簡介　51
1.4.10　獨占內存訪問指令　51
1.4.11　跳轉與比較指令　52
1.4.12　異常處理指令　53
1.4.13　系統寄存器訪問指令　54
1.5　GCC內聯匯編　55
1.6　函數調用標準和棧佈局　57
1.7　ARM64異常處理　59
1.7.1　異常類型　59
1.7.2　同步異常和異步異常　60
1.7.3　異常發生後的處理　60

第　2章 ARM64在Linux內核中的實現　62
2.1　ARM64內存管理　63
2.1.1　頁表　63
2.1.2　頁表映射　64
2.1.3　頁表項描述符　65
2.1.4　Linux內核中的頁表　68
2.1.5　ARM64內核內存分佈　74
2.1.6　案例分析：ARM64的頁表映射過程　78
2.2　高速緩存管理　84
2.3　TLB管理　87
2.4　內存屬性　90
2.4.1　內存屬性　91
2.4.2　高速緩存共享屬性　94
2.5　內存屏障　95
2.5.1　內存屏障指令　95
2.5.2　加載-獲取屏障原語與存儲-釋放屏障原語　96
2.6　Linux內核匯編代碼分析　97
2.6.1　鏈接文件基礎知識　97
2.6.2　vmlinux.lds.S文件分析　99
2.6.3　啟動匯編代碼　102
2.6.4　創建恆等映射和內核映像映射　106
2.6.5　__cpu_setup函數分析　114
2.6.6　__primary_switch函數分析　117
2.7　關於頁表的常見疑問　120
2.7.1　關於下一級頁表基地址　121
2.7.2　軟件遍歷頁表　121

第3章　內存管理之預備知識　124
3.1　從硬件角度看內存管理　126
3.1.1　內存管理的“遠古時代”　126
3.1.2　分段機制　127
3.1.3　分頁機制　128
3.1.4　虛擬地址到物理地址的轉換　128
3.2　從軟件角度看內存管理　129
3.2.1　從Linux系統使用者的角度看內存管理　129
3.2.2　從Linux應用程序開發人員的角度看內存管理　130
3.2.3　從內存分佈的角度看內存管理　131
3.2.4　從進程的角度看內存管理　131
3.2.5　從Linux內核的角度看內存管理　135
3.3　物理內存管理之預備知識　136
3.3.1　內存架構之UMA和NUMA　136
3.3.2　內存管理之數據結構　138
3.3.3　內存大小　140
3.3.4　物理內存映射　141
3.3.5　zone初始化　143
3.3.6　空間劃分　145
3.3.7　物理內存初始化　146

第4章　物理內存與虛擬內存　152
4.1　頁面分配之快速路徑　153
4.1.1　分配物理頁面的接口函數　154
4.1.2　分配掩碼　155
4.1.3　alloc_pages()函數　158
4.1.4　get_page_from_freelist()函數　162
4.1.5　zone_watermark_fast()函數　164
4.1.6　rmqueue()函數　165
4.1.7　釋放頁面　167
4.1.8　小結　170
4.2　slab分配器　170
4.2.1　slab分配器產生的背景　170
4.2.2　創建slab描述符　173
4.2.3　slab分配器的內存佈局　176
4.2.4　配置slab描述符　178
4.2.5　分配slab對象　180
4.2.6　釋放slab緩存對象　183
4.2.7　slab分配器和夥伴系統的接口函數　185
4.2.8　管理區　185
4.2.9　kmalloc()　188
4.2.10　小結　189
4.3　vmalloc()　190
4.4　虛擬內存管理之進程地址空間　194
4.4.1　進程地址空間　194
4.4.2　mm_struct數據結構　195
4.4.3　VMA數據結構　197
4.4.4　VMA的屬性　199
4.4.5　查找VMA　201
4.4.6　插入VMA　203
4.4.7　合並VMA　206
4.4.8　紅黑樹例子　207
4.4.9　小結　209
4.5　malloc()　210
4.5.1　brk系統調用　210
4.5.2　用戶態地址空間劃分　212
4.5.3　__do_sys_brk()函數　213
4.5.4　do_brk_flags()函數　213
4.5.5　＿mm＿populate()函數　215
4.5.6　get_user_pages()函數　216
4.5.7　小結　220
4.6　mmap　223
4.6.1　mmap概述　223
4.6.2　小結　225
4.7　缺頁異常處理　227
4.7.1　ARM64缺頁異常的底層處理流程　228
4.7.2　do_page_fault()函數　234
4.7.3　handle_mm_fault()函數　237
4.7.4　匿名頁面缺頁中斷　240
4.7.5　系統零頁　241
4.7.6　文件映射缺頁中斷　242
4.7.7　寫時復制　245
4.7.8　ARM64硬件DBM機制導致的競爭問題　248
4.7.9　關於pte_offset_map()安全使用的問題　251
4.7.10　關於寫時復制的競爭問題　253
4.7.11　為什麽要在切換頁表項之前刷新TLB　256
4.7.12　缺頁異常引發的死鎖　257
4.7.13　小結　257

第5章　內存管理之高級主題　259
5.1　page　260
5.1.1　page數據結構　260
5.1.2　_refcount的應用　265
5.1.3　_mapcount的應用　268
5.1.4　PG_Locked　269
5.1.5　mapping成員的妙用　270
5.1.6　和page相關的幾個接口函數　271
5.1.7　小結　272
5.2　RMAP　272
5.2.1　RMAP的主要數據結構　273
5.2.2　父進程產生匿名頁面　274
5.2.3　根據父進程創建子進程　277
5.2.4　子進程發生寫時復制　280
5.2.5　RMAP的應用　281
5.2.6　小結　283
5.3　頁面回收　285
5.3.1　LRU鏈表　285
5.3.2　第二次機會法　288
5.3.3　觸發頁面回收　293
5.3.4　kswapd內核線程　293
5.3.5　balance_pgdat()函數　296
5.3.6　shrink_node()函數　298
5.3.7　shrink_active_list()函數　302
5.3.8　shrink_inactive_list()函數　304
5.3.9　跟蹤LRU活動情況　308
5.3.10　頁面回收機制　309
5.3.11　Refault Distance算法　312
5.3.12　小結　317
5.4　匿名頁面生命周期　318
5.4.1　匿名頁面的產生　319
5.4.2　匿名頁面的使用　319
5.4.3　匿名頁面的換出　319
5.4.4　匿名頁面的換入　321
5.4.5　匿名頁面的銷毀　321
5.5　頁面遷移　321
5.5.1　哪些頁面可以遷移　322
5.5.2　頁面遷移主函數　322
5.5.3　move_to_new_page()函數　324
5.5.4　遷移頁表　325
5.5.5　遷移非LRU頁面　326
5.5.6　小結　328
5.6　內存規整　329
5.6.1　內存規整的基本原理　329
5.6.2　觸發內存規整　330
5.6.3　直接內存規整　330
5.6.4　compact_zone()函數　333
5.6.5　哪些頁面適合做內存規整　338
5.7　KSM　339
5.7.1　使能KSM　339
5.7.2　KSM基本實現　343
5.7.3　KSM數據結構　345
5.7.4　新版本KSM的新特性　345
5.7.5　malloc()分配的頁面可以被KSM掃描嗎　353
5.7.6　合並頁面　355
5.7.7　一個有趣的計算公式　358
5.7.8　page->index的值　359
5.7.9　小結　360
5.8　頁面分配之慢速路徑　362
5.8.1　alloc_pages_slowpath()函數　362
5.8.2　水位管理和分配優先級　367
5.9　內存碎片化管理　368
5.9.1　夥伴系統算法如何減少內存碎片　368
5.9.2　頁面遷移類型和內存規整　370
5.9.3　Linux 5.0內核新增的反碎片優化　371

第6章　內存管理之實戰案例分析　375
6.1　內存管理日誌信息和調試信息　375
6.1.1　vm_stat計數值　375
6.1.2　meminfo分析　377
6.1.3　夥伴系統信息　383
6.1.4　查看內存管理區的信息　383
6.1.5　查看與進程相關的內存信息　385
6.1.6　為什麽S_swap與P_swap不相等　387
6.1.7　解讀OOM Killer機制輸出的日誌信息　388
6.1.8　解讀缺頁異常後輸出的宕機日誌信息　394
6.2　內存管理調優參數　400
6.2.1　影響內存管理區水位的調優參數min_free_kbytes　401
6.2.2　影響頁面分配的參數lowmem_reserve_ratio　402
6.2.3　影響頁面回收的參數　404
6.2.4　影響臟頁回寫的參數　406
6.3　內存管理實戰案例分析　407
6.3.1　案例一：缺頁異常和文件系統引發的宕機　407
6.3.2　案例二：KSM和NUMA引發的虛擬機宕機　410
6.3.3　案例三：為什麽無法分配一個頁面　415
6.3.4　案例四：秘密任務——動態修改系統調用表引發的4次宕機　420

第7章　進程管理之基本概念　430
7.1　關於進程的基本概念　431
7.1.1　進程的來由　431
7.1.2　進程描述符　432
7.1.3　進程的生命周期　434
7.1.4　進程標識　436
7.1.5　進程間的家族關系　436
7.1.6　獲取當前進程　438
7.1.7　進程0和進程1　440
7.2　與進程創建和終止相關的操作系統原語　441
7.2.1　寫時復制技術　442
7.2.2　fork()函數　443
7.2.3　vfork()函數　444
7.2.4　clone()函數　445
7.2.5　內核線程　445
7.2.6　終止進程　446
7.2.7　僵屍進程和進程托孤　446
7.3　代碼分析：進程的創建和終止　447
7.3.1　_do_fork()函數分析　447
7.3.2　copy_process()函數分析　449
7.3.3　dup_task_struct()函數分析　453
7.3.4　sched_fork()函數分析　453
7.3.5　copy_mm()函數分析　454
7.3.6　進程創建後的返回　458
7.4　進程調度原語　461
7.4.1　進程分類　461
7.4.2　進程優先級和權重　461
7.4.3　調度策略　463
7.4.4　時間片　465
7.4.5　經典調度算法　465
7.4.6　Linux內核的O (n)調度算法　467
7.4.7　Linux內核的O (1)調度算法　467
7.4.8　Linux內核的CFS　468

第8章　進程管理之調度與負載均衡　469
8.1　CFS　470
8.1.1　vruntime的計算　471
8.1.2　調度器的數據結構　474
8.1.3　對進程創建代碼的分析　479
8.1.4　對進程加入調度器的代碼的分析　483
8.1.5　進程調度　485
8.1.6　進程切換　488
8.1.7　調度節拍　497
8.1.8　組調度機制　498
8.1.9　小結　502
8.2　負載計算　503
8.2.1　如何衡量一個CPU的負載　503
8.2.2　工作負載和量化負載　504
8.2.3　歷史累計衰減的計算　505
8.2.4　量化負載的計算　506
8.2.5　實際算力的計算　507
8.2.6　sched_avg數據結構　508
8.2.7　PELT代碼分析　510
8.2.8　PELT接口函數　516
8.3　SMP負載均衡　517
8.3.1　CPU管理位圖　517
8.3.2　CPU調度域　519
8.3.3　建立CPU調度域拓撲關系　522
8.3.4　負載均衡　529
8.3.5　喚醒進程　536
8.3.6　wake affine特性　538
8.3.7　調試　541
8.3.8　小結　542
8.4　綠色節能調度器　542
8.4.1　量化計算能力　545
8.4.2　能效模型　548
8.4.3　OPP子系統　551
8.4.4　初始化CPUfreq-dt驅動程序　556
8.4.5　註冊能效模型子系統　557
8.4.6　該選擇哪個CPU來執行喚醒進程p呢　561
8.4.7　overutilized條件判斷　569
8.4.8　CPU動態調頻　570
8.4.9　小結　573
8.5　實時調度　574
8.5.1　實時延時分析　574
8.5.2　Linux內核實時性改進　576

第9章　進程管理之調試與案例分析　580
9.1　進程管理之調試　580
9.1.1　查看與進程相關的調度信息　580
9.1.2　查看CFS的信息　582
9.1.3　查看調度域信息　585
9.1.4　與調度相關的調試節點　586
9.2　綜合案例分析——系統調度　587
9.3　進程管理　589
9.3.1　進程的本質　589
9.3.2　逃離不掉的進程優先級　590
9.3.3　調度器的選擇　591
9.3.4　用四維空間來理解負載　591
9.3.5　案例分析——為何不能調度　592
```
