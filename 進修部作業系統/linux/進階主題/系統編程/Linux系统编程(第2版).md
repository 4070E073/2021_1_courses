#
```
Linux系统编程(第2版)

[美]Robert Love 著

知名Linux内核专家撰写，从基础开始，直到高 级接口和优化技巧
https://www.ptpress.com.cn/shopping/buy?bookId=2b507834-7de8-4f51-adc2-f09e14892983
```

```
第 1章　入門和基本概念　1

1.1　系統程式設計　1

1.1.1　為什麼要學習系統程式設計　2

1.1.2　系統程式設計的基礎　2

1.1.3　系統調用　3

1.1.4　C庫　3

1.1.5　C編譯器　4

1.2　API和ABI　4

1.2.1　API　5

1.2.2　ABI　5

1.3　標準　6

1.3.1　POSIX和SUS的歷史　6

1.3.2　C語言標準　7

1.3.3　Linux和標準　8

1.3.4　本書和標準　8

1.4　Linux程式設計的概念　9

1.4.1　文件和檔案系統　9

1.4.2　進程　15

1.4.3　用戶和組　16

1.4.4　許可權　17

1.4.5　信號　18

1.4.6　進程間通信　19

1.4.7　標頭檔　19

1.4.8　錯誤處理　19

第 2章　文件I/O　23

2.1　打開文件　24

2.1.1　系統調用open()　24

2.1.2　新建文件的所有者　27

2.1.3　新建文件的許可權　27

2.1.4　creat()函數　30

2.1.5　返回值和錯誤碼　30

2.2　通過read()讀檔　31

2.2.1　返回值　31

2.2.2　讀入所有位元組　33

2.2.3　非阻塞讀　33

2.2.4　其他錯誤碼　34

2.2.5　read()調用的大小限制　34

2.3　調用write()寫　35

2.3.1　部分寫(Partial Write)　36

2.3.2　Append(追加)模式　36

2.3.3　非阻塞寫　37

2.3.4　其他錯誤碼　37

2.3.5　write()大小限制　38

2.3.6　write()行為　38

2.4　同步I/O　39

2.4.1　fsync()和fdatasync()　39

2.4.2　sync()　41

2.4.3　O_SYNC標誌位元　42

2.4.4　O_DSYNC和O_RSYNC　42

2.5　直接I/O　43

2.6　關閉文件　43

2.7　用lseek()查找　44

2.7.1　在文件末尾後查找　46

2.7.2　錯誤碼　46

2.7.3　限制　47

2.8　定位讀寫　47

2.9　文件截短　48

2.10　I/O多工　49

2.10.1　select()　50

2.10.2　poll()　56

2.10.3　poll()和select()的區別　60

2.11　內核內幕　61

2.11.1　虛擬檔案系統　61

2.11.2　頁緩存　62

2.11.3　頁回寫　63

2.12　結束語　64

第3章　緩衝I/O　65

3.1　用戶緩衝I/O　65

3.2　標準I/O　68

3.3　打開文件　69

3.4　通過檔描述符打開流　70

3.5　關閉流　71

3.6　從流中讀數據　71

3.6.1　每次讀取一個位元組　71

3.6.2　每次讀一行　72

3.6.3　讀二進位檔案　74

3.7　向流中寫數據　75

3.7.1　寫入單個字元　75

3.7.2　寫入字串　76

3.7.3　寫入二進位資料　76

3.8　緩衝I/O示例程式　77

3.9　定位流　78

3.10　Flush(刷新輸出)流　80

3.11　錯誤和檔結束　80

3.12　獲取關聯的檔描述符　81

3.13　控制緩衝　82

3.14　執行緒安全　83

3.14.1　手動文件加鎖　84

3.14.2　對流操作解鎖　85

3.15　對標準I/O的批評　86

3.16　結束語　87

第4章　高 級文件I/O　88

4.1　分散/聚集I/O　89

4.2　Event Poll　94

4.2.1　創建新的epoll實例　94

4.2.2　控制epoll　95

4.2.3　等待epoll事件　98

4.2.4　邊緣觸發事件和條件觸發事件　100

4.3　存儲映射　101

4.3.1　mmap()　101

4.3.2　munmap()　105

4.3.3　存儲映射實例　106

4.3.4　mmap()的優點　107

4.3.5　mmap()的不足　108

4.3.6　調整映射的大小　108

4.3.7　改變映射區域的許可權　109

4.3.8　通過映射同步檔　110

4.3.9　給出映射提示　112

4.4　普通檔I/O提示　114

4.4.1　系統調用posix_fadvise()　114

4.4.2　readahead()系統調用　115

4.4.3　“經濟實用”的操作提示　116

4.5　同步(Synchronized)，同步(Synchronous)及非同步(Asynchronous)操作　117

4.6　I/O調度器和I/O性能　118

4.6.1　磁片定址　119

4.6.2　I/O調度器的功能　120

4.6.3　改進讀請求　120

4.6.4　選擇和配置你的I/O調度器　123

4.6.5　優化I/O性能　124

4.7　結束語　130

第5章　進程管理　131

5.1　程式、進程和執行緒　131

5.2　進程ID　132

5.2.1　分配進程ID　132

5.2.2　進程體系　133

5.2.3　pid_t　133

5.2.4　獲取進程ID和父進程ID　133

5.3　運行新進程　134

5.3.1　exec系統調用　134

5.3.2　fork()系統調用　138

5.4　終止進程　141

5.4.1　終止進程的其他方式　142

5.4.2　atexit()　143

5.4.3　on_exit()　144

5.4.4　SIGCHLD　144

5.5　等待子進程終止　144

5.5.1　等待特定進程　147

5.5.2　等待子進程的其他方法　149

5.5.3　BSD中的wait3()和wait4()　151

5.5.4　創建並等待新進程　152

5.5.5　僵屍進程　155

5.6　用戶和組　155

5.6.1　改變實際用戶/組ID和保留的用戶/組ID　156

5.6.2　改變有效的用戶ID或組ID　157

5.6.3　BSD改變使用者ID和組ID的方式　158

5.6.4　HP-UX中改變使用者ID和組ID的方式　158

5.6.5　操作用戶ID/組ID的首 選方法　159

5.6.6　對保留的用戶ID的支援　159

5.6.7　獲取用戶ID和組ID　159

5.7　會話(Session)和進程組　160

5.7.1　與會話相關的系統調用　161

5.7.2　與進程組相關的系統調用　163

5.7.3　廢棄的進程組函數　164

5.8　守護進程　164

5.9　結束語　167

第6章　高 級進程管理　168

6.1　進程調度　168

6.1.1　時間片　169

6.1.2　I/O約束型進程和處理器約束型進程　169

6.1.3　搶佔式調度　170

6.2　完全公平調度器　171

6.3　讓出處理器　172

6.4　進程優先順序　173

6.4.1　nice()　174

6.4.2　getpriority()和setpriority()　175

6.4.3　I/O優先順序　176

6.5　處理器親和力(Affinity)　177

6.6　即時系統　180

6.6.1　硬即時系統和軟即時系統　180

6.6.2　延遲、抖動和截止期限　181

6.6.3　Linux的即時支持　182

6.6.4　Linux調度策略和優先順序　182

6.6.5　設置調度參數　186

6.6.6　sched_rr_get_interval()　189

6.6.7　關於即時進程的注意事項　190

6.6.8　確定性　191

6.7　資源限制　193

6.7.1　限制項　194

6.7.2　獲取和設置資源限制　198

第7章　執行緒　200

7.1　二進位程式、進程和執行緒　200

7.2　多執行緒　201

7.2.1　多執行緒代價　203

7.2.2　其他選擇　203

7.3　執行緒模型　203

7.3.1　使用者級執行緒模型　204

7.3.2　混合式執行緒模型　204

7.3.3　協同程式　205

7.4　執行緒模式　205

7.4.1　每個連接對應一個執行緒　206

7.4.2　事件驅動的執行緒模式　206

7.5　併發性、並行性和競爭　207

7.6　同步　210

7.6.1　互斥　211

7.6.2　鎖死　212

7.7　Pthreads　214

7.7.1　Linux執行緒實現　214

7.7.2　Pthread API　215

7.7.3　連結Pthreads　216

7.7.4　創建執行緒　216

7.7.5　執行緒ID　217

7.7.6　終止執行緒　218

7.7.7　join(加入)執行緒和detach(分離)執行緒　221

7.7.8　執行緒編碼實例　223

7.7.9　Pthread互斥　224

7.8　進一步研究　227

第8章　檔和目錄管理　228

8.1　文件及其中繼資料　228

8.1.1　一組stat函數　229

8.1.2　許可權　233

8.1.3　所有權　234

8.1.4　擴展屬性　237

8.1.5　擴展屬性操作　239

8.2　目錄　245

8.2.1　獲取當前工作目錄　246

8.2.2　創建目錄　251

8.2.3　刪除目錄　252

8.2.4　讀取目錄內容　253

8.3　連結　256

8.3.1　硬連結　256

8.3.2　符號連結　258

8.3.3　解除連結　259

8.4　拷貝和移動檔　261

8.4.1　拷貝　261

8.4.2　移動　261

8.5　設備節點　263

8.5.1　特殊設備節點　264

8.5.2　亂數產生器　264

8.6　帶外通信(Out-of-Band Communication)　265

8.7　監視檔事件　266

8.7.1　初始化inotify　267

8.7.2　監視　268

8.7.3　inotify事件　270

8.7.4　高 級監視選項　273

8.7.5　刪除inotify監視　273

8.7.6　獲取事件佇列大小　274

8.7.7　銷毀inotify實例　274

第9章　記憶體管理　276

9.1　進程位址空間　276

9.1.1　頁和頁面調度　276

9.1.2　記憶體區域　278

9.2　動態記憶體分配　279

9.2.1　陣列分配　281

9.2.2　調整已分配記憶體大小　282

9.2.3　釋放動態記憶體　283

9.2.4　對齊　285

9.3　資料段的管理　289

9.4　匿名記憶體映射　290

9.4.1　創建匿名記憶體映射　291

9.4.2　映射到設備檔/dev/zero　293

9.5　高 級記憶體分配　294

9.5.1　調試記憶體分配　297

9.5.2　獲取統計資訊　297

9.6　基於棧的分配　298

9.6.1　把字串複製到棧中　300

9.6.2　變長陣列　301

9.7　選擇合適的記憶體分配機制　302

9.8　記憶體操作　303

9.8.1　位元組設置　303

9.8.2　位元組比較　304

9.8.3　位元組移動　305

9.8.4　位元組查找　306

9.8.5　位元組加密　306

9.9　記憶體鎖定　307

9.9.1　鎖定部分位址空間　307

9.9.2　鎖定全部位址空間　308

9.9.3　記憶體解鎖　309

9.9.4　鎖的限制　310

9.9.5　該頁在實體記憶體中嗎　310

9.10　投機性記憶體分配策略　311

第 10章　信號　313
10.1　信號相關的概念　313
10.1.1　信號識別字　314
10.1.2　Linux支援的信號　315
10.2　基本信號管理　320
10.2.1　等待信號　321
10.2.2　示例　322
10.2.3　執行和繼承　324
10.2.4　把信號編號映射為字串　325
10.3　發送信號　326
10.3.1　許可權　326
10.3.2　示例　327
10.3.3　給進程本身發送信號　327
10.3.4　給整個進程組發送信號　327
10.4　重入　328
10.5　信號集　330
10.5.1　更多的信號集函數　331
10.5.2　獲取待處理信號　332
10.5.3　等待信號集　333
10.6　高 級信號管理　333
10.6.1　結構體siginfo_t　336
10.6.2　si_code的相關說明　338
10.6.3　發送帶附加資訊(payload)的信號　342
10.6.4　示例　343
10.7　信號是個UNIX“瑕疵”嗎　343

第 11章　時間　345
11.1　時間的資料結構　347
11.1.1　原始表示　348
11.1.2　微秒級精度　348
11.1.3　更精 確的：納秒級精度　348
11.1.4　對時間進行分解　349
11.1.5　進程時間類型　350
11.2　POSIX時鐘　351
11.3　時間源精度　351
11.4　取得當前時間　353
11.4.1　更好的介面　353
11.4.2　高 級介面　354
11.4.3　獲取進程時間　355
11.5　設置當前時間　356
11.5.1　設置支援高精度的時間　356
11.5.2　設置時間的高 級介面　357
11.6　玩轉時間　358
11.7　睡眠和等待　363
11.7.1　以微秒級精度睡眠　363
11.7.2　以納秒級精度睡眠　365
11.7.3　實現睡眠的高 級方法　366
11.7.4　sleep的可移植實現　368
11.7.5　超時(Overrun)　368
11.7.6　睡眠的其他方式　369
11.8　計時器　369
11.8.1　簡單的鬧鐘　369
11.8.2　計時器(interval timer)　370
11.8.3　高 級計時器　372

附錄A　C語言的GCC擴展　378
附錄B　參考書目　390

```
